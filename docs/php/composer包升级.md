# composer 包升级

本文从 composer 包升级任务，引出 composer 包生产环境升级技巧。全文共计 2429 字，阅读时间约 10 分钟， 作者：凌枫。如果文章对你有帮助，请关注和转发，谢谢！

## 一、把  composer 包升级下版本

温馨提示：以下故事纯属虚构，如有雷同纯属巧合。

### 1、无尽临时任务

临近下班，刚想起身喝口水，突然弹出条消息。连忙跑去领导工位， xxx 包准备要升级下。心里想着，这玩意两周前不是刚升级过呢？这周必须上线，有点急，你看下怎么搞，领导强调。你还想再多问几句。我还有个会议，你先测试环境升级观察下，领导打断，表情异常严肃。

回到工位，拿着口杯去打水，心里不停的犯嘀咕。手上一共还有 4 个任务在同时跟进，排期也是满满的，而领导只是交代这周上线，也没说我手上任务怎么办，难道这个包升级又要开发自测吗？马上到年底了，已经忙活了一整年。这时候水溢出来了。

### 2、毫无意义的工作

半小时后，独自一人踏进那家难以下咽的快餐店。吃完后，特意多沿着公司周围多绕了一圈，肚中的米饭和怨气似乎都消化掉了。回到工位，办公室已经没几个人了，自从降本增效后，爱加班的人几乎都消失了。

打开本地终端，敲下熟练的命令行。进入本地 PHP7.x 容器，指定要升级的 composer 包，升级到了 1.2.4 版本。对比了本次更新的 1.2.4 版本，和上次 1.2.3 版本，差异点也就是把包依赖的网络配置文件从 A 域名换到 B 域名。看到这，心里莫名的谩骂：**某些人的 KPI 调优，却要自己来买单，对他们来说或许只是 1 个简单变更，但是对自己来说却要升级 5 个系统和走 1 次发布流程。**

```bash
$ docker exec -it php72-for-dev sh // 进入php 7.x 容器
$ composer require "xxx/xxx: 1.2.4" -W // 升级到指定版本
$ composer dump-autoload -o // 更新优化
```

**知识点1：进入 PHP 7.x 容器命令解释。**&#x65;xec 是一个 docker 命令，用于在正在运行的容器中的执行命令。-i（--interactive） 参数指保持标准输入打开，允许向容器发送命令。-t（--tty）参数指分配一个伪终端，使容器内的 shell 能够以友好的交互模式运行。php72-for-dev 指一个正在运行的目标容器名称或者 ID。sh 指要在容器内执行的命令，这里指启动一个 shell 环境。

**知识点2：升级到指定版本命令解释。**&#x72;equire 是 composer 子命令，用于添加依赖包。xxx/xxx: 1.2.4 指要安装的包名为 xxx/xxx，版本为精确 1.2.4，加引号确保命令行正确解析。-W（--with-all-dependencies）指 composer 在执行更新时候，若遇到依赖包和项目中现有包不兼容，可以更全面的尝试解决这些冲突，而不是直接报错中止。

**知识点3：更新优化命令行解释。**&#x64;ump-autoload 是一个用于优化 composer 自动加载性能的命令。不带 -o 为默认模式，依赖 PSR-4 / PSR-0 规则的动态查找，最终会生成 autoload\_psr4.php 等基于命名空间映射的文件，在运行时候需要按目录结构逐级查找文件有 I/O 开销，性能较低一般使用场景在开发环境。而带 -o 为优化模式，会预生成完整的类映射表，最终会生成 autolaod\_classmap.php 等包含类命与文件路径的对应关系，在运行时候直接通过数组键命查找路径而避免文件 I/O 开销，性能较高一般适合在生产环境部署。

### 3、独自扛下了所有

自测验证通过。按照对项目的熟悉度，挑选了几个适合的场景，抓了几个测试环境的请求，简单构造后，验证均通过。这里或许你有疑问，改动这么小，也需要自测吗？嗯嗯，大厂嘛，作业规范嘛。代码就绪后，发布前置准备流程也都准备就绪，一切就绪就准备火箭发射（生产发布）了。

惊心动魄的上线。周五晚上，办公室依然是静悄悄的。心想，改动这么小，肯定也没什么问题，而且测试环境也跑了几天了。抱着侥幸的想法，发布就奔着快的方式，直接梭哈了。紧接着，短信、电话、领导问询等等纷纷来了。职业敏感度让我意识到大事不妙，根据报警及查看大盘二次确认后，条件反射般选择了发布回滚。回滚后，监控指标纷纷回落，紧接着定位原因，原来是网络不通：B 域名出现大量调用失败。于是找运维给域名 B 加白，心里再次默念：看来又是被选中吃螃蟹的那个人。

无尽追问及复盘总结。当晚，手忙脚乱的把问题处理完，同时还要面对一堆人的追问。他们也一样会收到报警信息，他们在意的是饭碗，和上一级的问询应付，而并不在意你的实际感受。第二天，你还要被拉进另外一堆人，对这件事情的溯源，假设你不够机智，最后事故责任人可能还是你。

温馨提示：以上故事纯属虚构，如有雷同纯属巧合。

## 二、composer 简单介绍

### 1、简单介绍

composer 是什么呢？composer本意是：a person who writes music, especially as a professional occupation. 当然它不是用来艺术创作的。官网是这样介绍的：A Dependency Manager for PHP，简而言之就是：一个为 PHP 而生的依赖管理工具。

相信绝大部分 PHP 开发者都使用过，那你有了解过它到底是怎么运行起来的吗？让我们一起来一探究竟。

### 2、使用演示

参照下列目录结构，进行 composer 项目初始化。先创建一个 composer.json 文件，再使用 composer install 命令进行安装，接着就可以在 index.php 中引入了。

```shell
.
├── composer.json // 手动创建
├── composer.lock
├── index.php // 手动创建
└── vendor
```

```json
{
  // composer.json 文件
  "require": {
    "monolog/monolog": "2.0.2"
  },
  "autoload": {
    "psr-4": {
      "Acme\\": "src/"
    }
  }
}
```

```php
// index.php 文件
require __DIR__ . '/vendor/autoload.php';

use Monolog\Logger;
use Monolog\Handler\StreamHandler;

// create a log channel
$log = new Logger('name');
$log->pushHandler(new StreamHandler('app.log', Logger::WARNING));

// add records to the log
$log->warning('Foo');
$log->error('Bar');
```

紧接着，你执行 index.php 文件后，可以看到目录下生成了 app.log 文件，里面有 2 行日志。

### 3、安装和运行

在运行 composer install，会读取 composer.json 配置中的 require 字段，然后从默认的包仓库 packagist 上查找 monolog/monolog，并下载其 2.0.2 版本及其所有依赖项到项目的 vendor 目录。而 composer.json 中的另一项配置 autoload 则定义配置自动加载规则，使用 PSR-4 标准，将项目中的 PHP 类文件与命名空间进行映射，实现自动加载，无须手动 include 文件。

在运行时，先假定已经执行过 composer dump-autoload -o 命令。首先，先通过 vendor/autoload.php 引导文件将 composer 引导类（CompoerAutoloaderInit....:getLoader()）载入；再实例化自动加载的核心类；最后通过 spl\_autoload\_register 函数将加载方法注册到 PHP 的 SPL 自动加载队列中；在实例化类时候，加载器会按照预设的优先级策略去寻找类文件。

## 三、生产实践经验

在升级 composer 包时候，你必须清楚意识到，这个操作在应用层面是无法回滚的。意味着出问题了，你没办法快速恢复，肯定要影响生产的。如果你的应用无法接受不可用时间，甚至无法经受产生错误报警。那么你必须做好一下准备。

永远不要当第一个吃螃蟹的人。除非你的包提供方，可以百分百承担责任，而且白纸黑字保证。除此之外，你永远不要当第一个吃螃蟹的人。

可随时降级回退。既然无法在应用层回滚，那么我们可以考虑在运维层做好降级回退。即不要发全部机器，而是选择性发少量机器，把影响面控制在可以接受的程度，再逐步放量，这样可以用时间换空间。

**如果文章对你有帮助，请关注和转发，谢谢！**

